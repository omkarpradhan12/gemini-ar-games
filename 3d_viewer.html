<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Workspace | Gesture Pro v7</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        #ui-container { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 100; }
        .panel { color: white; background: rgba(15, 15, 15, 0.9); padding: 20px; border-radius: 12px; border: 1px solid #00ffcc; width: 280px; backdrop-filter: blur(10px); box-shadow: 0 0 20px rgba(0,255,204,0.2); }
        #status { color: #00ffcc; font-weight: bold; margin-bottom: 10px; font-size: 0.8em; text-transform: uppercase; }
        .btn { background: #00ffcc; color: #000; border: none; padding: 10px; width: 100%; border-radius: 6px; font-weight: bold; cursor: pointer; text-transform: uppercase; margin-bottom: 8px; transition: 0.2s; }
        .btn:hover { background: #ffffff; }
        .btn-secondary { background: #333; color: #fff; }
        .btn-reset { background: #ff4444; color: white; }
        input[type=range] { width: 100%; accent-color: #00ffcc; cursor: pointer; }

        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 220px; height: 125px;
            border: 2px solid #00ffcc; border-radius: 8px; overflow: hidden; z-index: 100;
            transform: scaleX(-1); background: #000;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div class="panel">
            <div id="status">Status: Initializing...</div>
            <button class="btn" onclick="document.getElementById('fileInput').click()">Upload .GLB</button>
            <input type="file" id="fileInput" style="display:none" accept=".glb,.gltf">

            <div style="display: flex; gap: 5px;">
                <button class="btn btn-secondary" style="flex:1" onclick="resetObject()">Reset Object</button>
                <button class="btn btn-secondary" style="flex:1" onclick="resetView()">Reset Cam</button>
            </div>
            <button class="btn btn-reset" onclick="resetAll()">Reset All</button>

            <label style="font-size:0.7em; color:#00ffcc">MODEL SCALE</label>
            <input type="range" id="scaleSlider" min="0.1" max="5" step="0.1" value="1">

            <p style="font-size: 0.75em; color: #888; margin-top:15px;">
                âœŠ <b>Fist:</b> Orbit Camera<br>
                âœ‹ <b>Open Palm:</b> Rotate Object<br>
                ðŸ‘Œ <b>Pinch:</b> Zoom / Scale (2 hands)
            </p>
        </div>
    </div>

    <div id="video-preview">
        <video id="input_video" playsinline></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const status = document.getElementById('status');
        const videoElement = document.getElementById('input_video');
        const fileInput = document.getElementById('fileInput');
        const scaleSlider = document.getElementById('scaleSlider');

        let currentModelWrapper = new THREE.Group();
        let prevHandPos = [null, null];
        let initialPinchDist = null;
        let baseScale = 1;

        // Camera Logic
        let theta = 0, phi = Math.PI / 2.5, radius = 5;

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const grid = new THREE.GridHelper(20, 40, 0x00ffcc, 0x222222);
        scene.add(grid);

        // --- 2. Lighting & Defaults ---
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
        const dLight = new THREE.DirectionalLight(0xffffff, 1);
        dLight.position.set(5, 10, 7);
        scene.add(dLight);

        const defGeo = new THREE.TorusKnotGeometry(0.7, 0.25, 150, 20);
        const defMat = new THREE.MeshStandardMaterial({ color: 0x00ffcc, metalness: 0.9, roughness: 0.1 });
        const defMesh = new THREE.Mesh(defGeo, defMat);
        currentModelWrapper.add(defMesh);
        scene.add(currentModelWrapper);

        function updateCameraPosition() {
            camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
            camera.position.y = radius * Math.cos(phi);
            camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
            camera.lookAt(0, 0, 0);
        }

        function resetView() {
            theta = 0; phi = Math.PI / 2.5; radius = 5;
            updateCameraPosition();
        }

        function resetObject() {
            currentModelWrapper.rotation.set(0, 0, 0);
            scaleSlider.value = 1;
        }

        function resetAll() {
            resetView();
            resetObject();
        }

        resetAll();

        // --- 3. Hand Markers ---
        const handGroup = new THREE.Group();
        camera.add(handGroup);
        scene.add(camera);

        function createHandVis() {
            const g = new THREE.Group();
            for(let i=0; i<21; i++) {
                const s = new THREE.Mesh(new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({ color: 0x00ffcc, depthTest: false }));
                g.add(s);
            }
            return g;
        }
        const leftH = createHandVis();
        const rightH = createHandVis();
        handGroup.add(leftH, rightH);

        // --- 4. Gesture Helpers ---
        const getDist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const isFist = (lm) => lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
        const isOpenPalm = (lm) => lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[20].y < lm[18].y;
        const isPinching = (lm) => getDist(lm[4], lm[8]) < 0.04;

        function onResults(results) {
            leftH.visible = rightH.visible = false;
            if (!results.multiHandLandmarks) {
                prevHandPos = [null, null];
                return;
            }

            let pinches = [];

            results.multiHandLandmarks.forEach((landmarks, index) => {
                const isRight = results.multiHandedness[index].label === 'Left';
                const hVis = isRight ? rightH : leftH;
                hVis.visible = true;

                landmarks.forEach((p, i) => {
                    hVis.children[i].position.set((p.x - 0.5) * -4, (p.y - 0.5) * -2.5, -2.5);
                });

                const fist = isFist(landmarks);
                const palm = isOpenPalm(landmarks);
                const pinch = isPinching(landmarks);

                if (prevHandPos[index]) {
                    const dx = (landmarks[9].x - prevHandPos[index].x) * 5;
                    const dy = (landmarks[9].y - prevHandPos[index].y) * 5;

                    // 1. FIST: ORBIT CAMERA
                    if (fist) {
                        theta += dx;
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + dy));
                        updateCameraPosition();
                    }

                    // 2. OPEN PALM: ROTATE OBJECT
                    if (palm && !fist) {
                        currentModelWrapper.rotation.y += dx * 2;
                        currentModelWrapper.rotation.x += dy * 2;
                    }

                    if (pinch) pinches.push(landmarks[8]);
                }
                prevHandPos[index] = { x: landmarks[9].x, y: landmarks[9].y };
            });

            // 3. DOUBLE PINCH: SCALE
            if (pinches.length === 2) {
                const d = getDist(pinches[0], pinches[1]);
                if (initialPinchDist === null) {
                    initialPinchDist = d;
                    baseScale = parseFloat(scaleSlider.value);
                } else {
                    scaleSlider.value = Math.min(Math.max(baseScale * (d / initialPinchDist), 0.1), 5);
                }
            } else {
                initialPinchDist = null;
            }

            currentModelWrapper.scale.setScalar(parseFloat(scaleSlider.value));
        }

        // --- 5. Start ---
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            new THREE.GLTFLoader().load(URL.createObjectURL(file), (g) => {
                currentModelWrapper.clear();
                const model = g.scene;
                const b = new THREE.Box3().setFromObject(model);
                model.position.sub(b.getCenter(new THREE.Vector3()));
                currentModelWrapper.add(model);
                status.innerText = "Model: " + file.name;
            });
        };

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6});
        hands.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 1280, height: 720
        });
        cam.start().then(() => status.innerText = "Status: Online");

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
